/**
 * <h3>第4章 对象的组合</h3> 我们不希望每一次内存访问都需要进行分析以确保线程安全的，<br>
 * 而是希望将一些 现有的线程安全组件组合为更大规模的组件或程序。
 * 
 * <h4>4.1 设计线程安全的类</h4> 在设计线程安全的过程中，需要包含以下三个基本要素: <br>
 * <ol>
 * <li>找出构成对象状态的所有变量</li>
 * <li>找出约束状态变量的所有不变性条件</li>
 * <li>建立对对象状态的访问策略</li>
 * </ol>
 * 要分析对象的状态，首先从对象的域开始。<br>
 * 如果对象中所有的域都是基本类型，那么这些域构成对象的全部状态;<br>
 * 如果对象中的域引用了其他的对象，对象的状态将包含被引用对象的域。
 * <p>
 * {@link Counter 安全计数器}
 * <h5>4.1.1 收集同步需求</h5> 对象与变量都有一个状态空间，即所有的取值。状态空间越小，越容易判断现成的状态。
 * <p>
 * 判断状态是否有效，可以从以下方面着手: <br>
 * <ol>
 * <li>类中定义的不变性条件。<br>
 * 例如: Counter中的value域是long型变量，其取值范围 从Long.MIN_VALUE到Long.MAX_VALUE。<br>
 * 另外，value在Counter中不能为负。</li>
 * <li>状态的迁移可能包含有后验条件。<br>
 * 如果Counter的当前状态为17，那么它的下一 状态只能是18。当下一个操作需要依赖当前状态时，这一定是个复合操作。<br>
 * 并非所有 的状态转换都要施加限制，当更新一个储存当前温度的变量，与之前的状态无关。</li>
 * <li>由于不变性和后验条件在状态及状态转换上施加的各种约束，因此需要额外的同步与 封装。<br>
 * 如果某些状态是无效的，那么必须对底层的状态变量进行封装，否则客户代码 可能会使对象处于无效状态。<br>
 * 如果在某个操作中存在着无效的状态转换，那么该操作必须是原子的。<br>
 * 例如: 在一个数值范围的类中包含上界和下界两个状态变量。<br>
 * 这些变量必须遵守的约 束是下界值等于或小于上界值。类似于这种包含多变量的不变性条件将带来原子性需求。 <br>
 * 即这些变量必须在单个原子操作中读取或更新，否则会破坏不变性。<br>
 * 如果类中没有施加这种约束，可以放宽封装和序列化要求，以获得更高的灵活性和性能。</li>
 * </ol>
 * <h5>4.1.2 依赖状态的操作</h5> 在某些对象中还存在一些基于状态的先验条件。例如: 不能从空队列中删除元素。<br>
 * 如果某个操作中有基于状态的先验条件，呢么这个操作被称为依赖状态的操作。<br>
 * 在单线程中，如果某个操作不满足先验条件，就只能失败，然而在并发程序中，会一直 等到先验条件为真时再执行操作。
 * <h5>4.1.3 状态的所有权</h5> 垃圾回收机制使我们避免处理所有权问题。
 * <h4>4.2 实例封闭</h4> 如果某个对象不是线程安全的，可以通过线程封闭，或通过一个锁保护对象的所有访问。 <br>
 * 在这里，健介绍一个实例封闭机制(Instance Confinement)，将对象封闭到另一个对 象中，这样访问被封装对象的访问路径是可知的。<br>
 * 将封闭机制和加锁策略结合起来， 可以确保以线程安全的方式使用非线程安全的对象。{@link PersonSet 封闭与加锁机制}
 * <p>
 * Java中有些基本容器并不是线程安全，但类库提供了包装器工厂方法({@link Collections.synchronizedList}及其类似方法)，<br>
 * 通过装饰器模型将容器类封装到同 步包装器对象中，将接口中每个方法实现为同步方法，且调用请求转发到底层容器对象。
 * <h5>4.2.1 Java监视器模式</h5> 遵循监视器模式的对象会把对象所有的状态封装起来，并由对象自己的内置锁保护。<br>
 * {@link PrivateLock 私有锁}相比内置锁有许多优点，私有锁可以将锁封闭起来，客户 代码无法得到锁，但是可以通过公有方法来访问锁，<br>
 * 如果客户代码错误地获得了另 一个对象的锁，可能会产生活跃性问题。
 * <h5>4.2.2 示例: 车辆追踪</h5> {@link MonitorVehicleTracker 基于监视器模式的车辆追踪器}
 * <h4>4.3 线程安全性的委托</h4> 从头构建一个类或将多个非线程安全的类组合为一个类时，Java监视器模式是很有用的。 <br>
 * 当各个组件都是线程安全的条件下，需视情况而制定个额外的线程安全层。
 * <p>
 * 在{@link CountingFactorizer}中，它的线程安全委托给AtomicLong来保证。
 * <h5>4.3.1 示例: 基于委托的车辆追踪器</h5> {@link DelegatingVehicleTracker 基于委托的车辆追踪器}
 * <h5>4.3.2 独立的状态变量</h5> 我们可以把线程安全性委托给多个状态变量，<br>
 * 只要各个状态变量是相互独立的， 即组合而成的类不会再其包含的多个状态变量上增添任何不可变条件。
 * <p>
 * {@link VisualComponent 多个状态变量相互独立}
 * <h5>4.3.3 委托失效时</h5> 如果一个类是由多个独立且线程安全的状态变量组成，并且所有操作都不存在无效转换， <br>
 * 那么线程安全可以委托给底层变量。
 * <p>
 * {@link NumberRange 多个状态变量之间存在不变性条件}
 * <h5>4.3.4 发布底层的状态变量</h5> 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束，在变量的操作上也
 * 不存在任何不允许的状态转换，<br>
 * 那么这个状态变量是可以安全发布的。
 * <h5>4.3.5 示例: 发布状态的车辆追踪器</h5> {@link PublishingVehicleTracker 发布状态的车辆追踪器}
 * 
 * <h4>4.4 在现有的线程安全类中添加功能</h4> 现有的基础模块只能支持大部分操作，当需要添加一个新的操作时。有以下方法:
 * <ol>
 * <li>修改原始类是最安全的方法，但往往是不可能的。</li>
 * <li>另一种方法是{@link BetterVector 扩展类}</li>
 * </ol>
 * <h5>4.4.1 客户端加锁机制</h5>
 * 对于Collections.synchronizedList封装的ArrayList，上面两个方法都行不通，<br>
 * 因为客户端代码不知道同步封装器工厂方法中返回的List对象的类型。
 * <p>
 * 可以通过扩展类的功能，而不是类本身，将扩展代码放入一个{@link BadListHelper 辅助类}中。
 * <p>
 * 扩展类是脆弱的，因为它将类的加锁代码分布到多个类中，而客户端加锁是更加脆弱的， 由于将类的加锁代码分散到与它无关的其他类中。
 * <h5>4.4.2 组合</h5> {@link ImprovedList 组合(Composition)}
 * <h4>4.5 将同步策略文档化</h4> 在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员理解的同步策略。
 */
package jcip.ex04;
