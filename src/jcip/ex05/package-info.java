/**
 * <h3>第5章 基础构建模块</h3> 委托是创建线程安全类的一个最有效策略，只需让现有的线程安全类管理所有的状态。
 * <p>
 * 介绍线程安全的容器类以及各种用于协调多个相互控制的线程控制流的同步工具类 (Synchronizer)
 * <p>
 * 
 * <h4>5.1 同步容器类</h4> 同步容器类包括Vector和Hashtable。<br>
 * 此外还有由Collections.SynchronizedXxx等 工厂方法创建的同步封装器，<br>
 * 这些类实现线程安全的方式是将它们的状态封装起来， 并对每一个公有方法进行同步，使得每次只有一个线程访问到容器的状态。
 * <h5>5.1.1 同步容器类的问题</h5> 同步容器类是线程安全的，但在进行复合操作时需要额外的客户端加锁。<br>
 * 例如:
 * <ul>
 * <li>迭代，反复访问元素，直到遍历完容器所有元素</li>
 * <li>跳转，根据指定顺序找到当前元素的下一个元素</li>
 * <li>条件运算，如若没有则添加</li>
 * </ul>
 * {@link UnsafeVectorHelpers 导致混乱结果的复合操作} {@link SafeVectorHelpers 客户端加锁的复合操作}
 * <h5>5.1.2 迭代器与ConcurrentModificationException</h5>
 * <h5>5.1.3 隐藏迭代器</h5>
 * 
 * <h4>5.2 并发容器</h4>
 * <h5>5.2.1 ConcurrentHashMap</h5>
 * <h5>5.2.2 额外的原子Map操作</h5>
 * <h5>5.2.3 CopyOnWriteList</h5>
 * 
 * <h4>5.3 阻塞队列和生产者-消费者模式</h4>
 * <h5>5.3.1 示例: 桌面搜索</h5>
 * <h5>5.3.2 串行线程封闭</h5>
 * <h5>5.3.3 双端队列与工作密取</h5>
 * 
 * <h4>5.4 阻塞方法与中断方法</h4>
 * 
 * <h4>5.5 同步工具类</h4>
 * <h5>5.4.1 闭锁</h5>
 * <h5>5.4.2 FutureTask</h5>
 * <h5>5.4.3 信号量</h5>
 * <h5>5.4.4 栅栏</h5>
 * 
 * <h4>5.6 构建高效且可伸缩的结果缓存</h4>
 */
package jcip.ex05;
