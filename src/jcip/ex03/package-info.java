/**
 * <h3>第3章 对象的共享</h3> 第2章介绍了通过同步避免多个线程在同一时刻访问相同的数据，<br>
 * 本章将介绍如何共享和发布对象，<br>
 * 这将是构建线程安全类和使用concurrent类库构建并发程序的重要基础。<br>
 * <p>
 * 关键字synchronized不仅用于实现原子性和确定<b>临界区(Critical Section)</b>,<br>
 * 同步还有一个重要的方面<b>内存可见性(Memory Visibility)</b><br>
 * <p>
 * 我们希望
 * <li>防止某个线程在使用对象状态的同时另一个线程在修改该状态</li>
 * <li>确保一个线程在修改对象状态后，其他线程能够看见发生的状态变化</li>
 * 
 * <h4>3.1 可见性</h4> 当读操作与写操作在不同的线程中执行时，<br>
 * 会出现{@link NoVisibility 意料之外的情况}
 * <h5>3.1.1 失效数据</h5> {@link MutableInteger get/set操作没有同步}<br>
 * {@link SynchronizedInteger get/set操作同步}
 * <h5>3.1.2 非原子的64位操作</h5> 失效数据至少是之前某个线程设置的值，而不是随机值。<br>
 * 这种安全性保证称之为最低安全性(out-of-thin-airsafety)。<br>
 * 最低安全性适应于大多数的变量, 但对于非volatile的64位数值变量(double,long)。<br>
 * 由于JVM允许将64位的读或写操作分解成两个32位的操作,<br>
 * 在没有同步的情况下，可能读取到某个值的高32位和其他值的低32位。
 * <h5>3.1.3 加锁与可见性</h5> 对于某个共享且可变的变量要求所有线程在同一锁上同步，<br>
 * 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。<br>
 * 为了确保所有线程能看到共享变量的最新值，所有执行读写操作的线程都要在同一锁上。
 * <h5>3.1.4 Volatile变量</h5>
 * <ol>
 * <li>不会将该变量上的操作与其他内存操作一起重排序</li>
 * <li>不会缓存到寄存器或者其他处理器看不见的地方</li>
 * </ol>
 * 如果在验证准确性需要对可见性作复杂的判断，不要使用Volatile，<br>
 * 可以在以下情况使用Volatile变量<br>
 * <ol>
 * <li>确保它们自身状态的可见性</li>
 * <li>确保它们所引用对象的状态的可见性</li>
 * <li>表示一些重要的生命周期事件的发生(初始化或关闭)</li>
 * </ol>
 * 这是一个使用Volatile变量的{@link CountingSheep 示例}。
 * <p>
 * 加锁机制可以确保可见性和原子性，而Volatile只能确保原子性，<br>
 * 原子变量提供<b>读-改-写</b>的原子操作，被视为更好的Volatile。
 * <p>
 * 当且仅当满足以下所有条件时，才使用Volatile: <br>
 * <ul>
 * <li>变量的写入操作不依赖于变量的当前值，(递增或递减)；或单线程更新变量的值</li>
 * <li>该变量不会与其他的状态变量纳入不变性条件中</li>
 * <li>访问该变量时可不须加锁</li>
 * </ul>
 * 
 * <h4>3.2 发布与逸出</h4> 发布(Publish)是指使对象能够在当前作用域之外的代码中使用。 {@link Secrets
 * 发布一个对象}<br>
 * 逸出(Escape)是指本不该发布的对象被发布时的情况。 {@link UnsafeStates 内部的可变状态逸出}<br>
 * 最后一种发布对象或其内部状态的机制就是发布一个 {@link ThisEscape 内部类逸出实例}。
 * <p>
 * 
 * <h4>3.3 线程封闭</h4> 一种避免使用同步的方式是不共享数据，如果仅在单线程内访问数据，就不需同步。<br>
 * 这种技术是线程封闭(Thread Confinement)，这种用法将自动实现线程安全。
 * <p>
 * 常见示例：
 * <ol>
 * <li>Swing的可视化组件和数据模型对象</li>
 * <li>JDBC的Connection对象</li>
 * </ol>
 * <h5>3.3.1 Ad-hoc线程封闭</h5> 完全由程序来实现封闭，这是十分脆弱的。
 * <h5>3.3.2 栈封闭</h5> 只能通过局部变量才能访问对象，局部变量的固有属性之一就是封闭在执行线程中。 {@link Animals
 * 栈封闭示例}
 * <h5>3.3.3 ThreadLocal类</h5> 这个类能使线程的threadLocalHashCode值与要保存的对象进行关联，<br>
 * ThreadLocal提供了get/set等访问接口或方法，get方法会返回set后的值或一个初始值<br>
 * 这些特定于线程的值保存在Thread对象中，线程中止，这些值也会被垃圾回收。 {@link ConnectionDispenser
 * ThreadLocal示例}
 * <p>
 * 
 * <h4>3.4 不变性</h4> 前面提到的原子性和可见性涉及的得到失效值，观测对象处于不一致的状态等等问题，<br>
 * 都与多线程同时访问一个可变的状态有关，如果使用不可变对象(Immutable Object)，<br>
 * 那么这些问题与复杂性就自然消失了。
 * <p>
 * 不可变对象只有一种状态，并且该状态由构造函数来控制。<br>
 * 在Java中，即使对象中所有的域都是final，这个对象仍然是可变的，<br>
 * final类型的域中可保存对可变对象的引用。
 * <p>
 * {@link ThreeStooges 在可变对象的基础上构建的不可变类}
 * <h5>3.4.1 Final域</h5> 关键字final可视为C++中const机制的一种受限版本，在Java内存模型中，<br>
 * final域能确保初始化过程的安全性，从而可以不受限地访问对象，共享对象时无需同步。
 * <p>
 * 良好的编程习惯
 * <ul>
 * <li>除非需要更高的可见性，否则应将所有的域声明为私有域</li>
 * <li>除非需要某个域是可变的，否则应将所有的与声明为final域</li>
 * </ul>
 * <h5>3.4.2 用volatile发布不可变对象</h5> {@link OneValueCache 对数值及其因数分解结果进行缓存的不可变容器类}
 * <p>
 * 对于访问和更新多个相关变量时出现的竞争条件问题，<br>
 * 可以将这些变量保存到一个不可变类中消除它。如果要更新不可变对象中的状态，<br>
 * 可以创建一个新的容器对象，通过Volatile来确保其他持有源对象引用的线程看见 {@link VolatileCachedFactorizer
 * 对象处于一致的状态}
 * <p>
 * 
 * <h4>3.5 安全发布</h4> 在某些情况下，我们希望在多个线程间共享变量，<br>
 * 如果只是将{@link 对象引用保存到公有域中}，这是不安全的发布。<br>
 * <p>
 * <h5>3.5.1 不正确的发布: 正确的对象被破坏</h5> {@link Holder 未被正确发布}
 * <h5>3.5.2 不可变对象与初始化安全性</h5> Java内存模型为不可变对象提供了一中特殊的初始化安全保证。我们知道，<br>
 * 即使某个对象的引用对于其他线程来说是可见的，并不意味着对象的状态 对于使用线程来说是可见的。<br>
 * 为了确保对象的状态呈现出一致的视图，必须使用同步。
 * <p>
 * 另一方面，即使发布不可变对象的引用时没有使用同步，也可以安全地访问该对象。<br>
 * 为了维持初始化安全性的保证，必须满足不变性的所有需求。
 * <h5>3.5.3 安全发布的常用模式</h5> 一个正确构建的对象可以通过以下方式来安全发布: <br>
 * <ul>
 * <li>在静态初始化函数中初始化一个对象引用</li>
 * <li>将对象的引用保存到volatile类型或者AtomicReferance对象中</li>
 * <li>将对象的引用保存到正确构建的对象的final域中</li>
 * <li>将对象的引用保存到一个由锁保护的域中</li>
 * </ul>
 * 通常发布一个静态的对象，最简单，最安全的方式是使用静态的初始化器。<br>
 * 
 * <pre>
 * public static Holder holder = new Holder(42);
 * </pre>
 * 
 * 静态初始化器由JVM在类的初始化阶段执行，由于JVM内部存在着同步机制，<br>
 * 因此通过这种方式初始化的任何对象都可以被安全发布。
 * <p>
 * 线程安全的容器类提供以下的安全发布: <br>
 * <ul>
 * <li>通过将一个键或者值放入Hashtable，synchronizedMap，concurrentMap中。<br>
 * 可以安全地将它发布给任何从这些容器中访问它的线程。</li>
 * <li>通过将某个元素放入Vector，CopyOnWriteArrayList，CopyOnWriteArrayset，
 * synchronizedList，synchronizedSet中。</li>
 * <li>通过将某个元素放入BlockingQueue，concurrentLinkedQueue中。</li>
 * </ul>
 * <h5>3.5.4 事实不可变对象</h5> 如果对象在技术上是可变的，但状态在发布后不再改变，那么把这种对象称为 事实不可变对象(Effectively
 * Immutable Object)。<br>
 * 这些对象不需要满足3.4节中 提出的严格性定义。<br>
 * 例如，Date对象的值放入Map后不再改变，那么 synchronizedMap提供的同步机制足以使Date值安全发布，并且不需要额外的同步。
 * <h5>3.5.5 可变对象</h5> 对于可变对象，安全发布只能确保在发布当时状态的可见性。<br>
 * 可变对象不仅要在 发布时需要同步，并且在每次的对象访问都需要使用同步来确保后续修改操作的可见性。
 * <p>
 * 对象的发布需要取决于它的可变性: <br>
 * <ol>
 * <li>不可变对象可以通过任意机制来发布</li>
 * <li>事实不可变对象必须通过安全方式来发布</li>
 * <li>可变对象必须通过安全方式来发布，并且必须是线程安全的或由某个锁保护起来</li>
 * </ol>
 * <h5>3.5.6 安全地共享对象</h5> 在并发程序中使用和共享对象时，可以使用一些使用的策略: <br>
 * <ol>
 * <li><b>线程封闭: </b> 线程封闭的对象只能由一个线程拥有，并且对象只能由线程来修改。</li>
 * <li><b>只读共享: </b> 在没有额外同步的情况下，可以允许多个线程访问对象，但任何线程都不能修改它。<br>
 * 包含不可变对象和事实不可变对象。<br>
 * </li>
 * <li><b>线程安全共享: </b> 线程安全的对象在其内部实现同步，因此任何线程都可通过对象的公用接口来访问它。</li>
 * <li><b>保护对象: </b>< 被保护的对象只能通过特定的锁来访问。<br>
 * 它包括封装在线程安全对象中的对象， 以及已发布的并且由某个特定锁保护的对象。</li>
 * </ol>
 */
package jcip.ex03;
