# Concurrency 

## 入门

### 并发编程的背景
    (1) 线程上下文切换的开销
    (2) 死锁
    (3) 资源限制

### 并发编程的基础
    (1) CPU 的缓存行
    (2) CPU 的总线锁和缓存锁
    (3) CPU 的缓存一致性协议
    (4) CPU 的伪共享问题 false sharing 

### 并发编程的底层设施
    (1) volatile 的实现原理与应用
    (2) synchronized 的原理与应用
    (3) 原子操作的原理与应用
    
### Java 并发编程的基础 Thread 库
    (1) 隐藏的线程
    (2) 线程的优先级
    (3) 线程的状态
    (4) Daemon线程
    (5) 线程的过期方法
    (6) Synchronized
    (7) Java 的等待/通知机制
    (8) 线程间的数据传输
    (9) 线程的本地变量 ThreadLocal
    (A) 线程池技术

## 登堂

### 线程间的通信
    (1) volatile 变量
    (2) CAS(compareAndSet 方法) 构成的内存语义

### 基础类
    (1) AQS(AbstractQueuedSynchronizer) 
    (2) 非阻塞数据结构
    (3) 原子变量类

### 高层框架
    (1) Lock 锁
    (2) 同步器
    (3) 阻塞队列
    (4) Executor
    (5) 并发容器

## 入室

### 并发编程的关键
    (1) 线程之间如何通信 
    (2) 线程之间如何同步

### 平台的内存模型
    在共享内存的多处理器体系中, 每个处理器都拥有自己的缓存, 并定期与主内存进行协调。 
    缓存与主存是通过缓存一致性来进行协调, 而不同的处理器有不同的级别, JMM 会屏蔽这个差异。

### 重排序
    编译器和处理器为了优化程序性能会对指令序列进行重新排序的手段。

### 顺序一致性
    (1) 所有线程的操作都必须确保在整体的操作上看到的顺序是同当前线程的操作顺序是一致的
    (2) 所有的线程都只能看到一个单一的操作执行顺序, 即每个操作都是原子执行且对所有线程可见
    
### volatile 的内存语义

### Lock 锁的内存语义

### Final 域的内存语义

### JSR-133 内存模型简介
